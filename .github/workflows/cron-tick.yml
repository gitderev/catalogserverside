name: Cron Tick (every 1 minute)

on:
  # Schedule disabled: cron-tick is now invoked by Supabase pg_cron (job: cron-tick-every-minute)
  # To re-enable GitHub Actions as fallback, uncomment the next two lines:
  # schedule:
  #   - cron: "* * * * *"
  workflow_dispatch: {}

concurrency:
  group: cron-tick
  cancel-in-progress: false

jobs:
  cron-tick:
    runs-on: ubuntu-latest
    timeout-minutes: 3
    steps:
      - name: Validate secrets
        run: |
          if [ -z "${{ secrets.CRON_TICK_URL }}" ]; then
            echo "::error::Secret CRON_TICK_URL is not configured. Go to Settings > Secrets and variables > Actions and add CRON_TICK_URL (the full URL of your cron-tick Edge Function, e.g. https://<project-id>.supabase.co/functions/v1/cron-tick)."
            exit 1
          fi
          if [ -z "${{ secrets.CRON_SECRET }}" ]; then
            echo "::error::Secret CRON_SECRET is not configured. Go to Settings > Secrets and variables > Actions and add CRON_SECRET (must match the CRON_SECRET Supabase secret)."
            exit 1
          fi

      - name: Call cron-tick (single call per minute)
        run: |
          set -e
          TS=$(date -u +%Y-%m-%dT%H:%M:%SZ)
          echo "--- cron-tick ts=$TS ---"

          BODY_FILE=$(mktemp)

          # Disable fail-fast to capture curl exit code
          set +e
          HTTP_STATUS=$(curl -sS -o "$BODY_FILE" -w "%{http_code}" \
            --fail \
            --max-time 90 \
            -X POST "${{ secrets.CRON_TICK_URL }}" \
            -H "Content-Type: application/json" \
            -H "x-cron-secret: ${{ secrets.CRON_SECRET }}" \
            -d '{"timestamp":"'"$TS"'"}')
          CURL_EXIT=$?
          set -e

          BODY=$(cat "$BODY_FILE" 2>/dev/null || echo "")
          rm -f "$BODY_FILE"
          BODY_TRUNCATED=$(printf '%s' "$BODY" | head -c 500)

          echo "curl_exit=$CURL_EXIT http_status=$HTTP_STATUS ts=$TS"
          echo "body=$BODY_TRUNCATED"

          # TIMEOUT (curl 28): log and exit cleanly — next minute's tick will handle it.
          if [ "$CURL_EXIT" -eq 28 ]; then
            echo "::warning::curl timeout (exit=28, http=$HTTP_STATUS) at $TS — delegating to next tick"
            exit 0
          fi

          if [ "$CURL_EXIT" -ne 0 ]; then
            echo "::error::cron-tick curl failed (exit=$CURL_EXIT, http=$HTTP_STATUS) at $TS"
            echo "::error::body=$BODY_TRUNCATED"
            exit 1
          fi

          # Parse status from JSON response
          RESP_STATUS=$(python3 -c "
          import json, sys
          try:
              data = json.loads(sys.argv[1])
              print(data.get('status', 'unknown'))
          except Exception:
              print('unknown')
          " "$BODY" 2>/dev/null || echo "unknown")

          echo "parsed_status=$RESP_STATUS http=$HTTP_STATUS curl_exit=$CURL_EXIT ts=$TS"
          echo "cron-tick completed (status=$RESP_STATUS)"
