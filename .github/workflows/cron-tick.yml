name: Cron Tick (every 1 minute)

on:
  schedule:
    - cron: "* * * * *"
  workflow_dispatch: {}

concurrency:
  group: cron-tick
  cancel-in-progress: false

jobs:
  cron-tick:
    runs-on: ubuntu-latest
    timeout-minutes: 11
    env:
      TICK_MAX_CALLS: "4"
      TICK_SLEEP_SEC: "20"
    steps:
      - name: Validate secrets
        run: |
          if [ -z "${{ secrets.CRON_TICK_URL }}" ]; then
            echo "::error::Secret CRON_TICK_URL is not configured. Go to Settings > Secrets and variables > Actions and add CRON_TICK_URL (the full URL of your cron-tick Edge Function, e.g. https://<project-id>.supabase.co/functions/v1/cron-tick)."
            exit 1
          fi
          if [ -z "${{ secrets.CRON_SECRET }}" ]; then
            echo "::error::Secret CRON_SECRET is not configured. Go to Settings > Secrets and variables > Actions and add CRON_SECRET (must match the CRON_SECRET Supabase secret)."
            exit 1
          fi

      - name: Call cron-tick loop
        run: |
          set -e
          TIMEOUT_COUNT=0

          for ATTEMPT in $(seq 1 "$TICK_MAX_CALLS"); do
            TS=$(date -u +%Y-%m-%dT%H:%M:%SZ)
            echo "--- attempt $ATTEMPT/$TICK_MAX_CALLS ts=$TS ---"

            BODY_FILE=$(mktemp)

            # Disable fail-fast to capture curl exit code
            set +e
            HTTP_STATUS=$(curl -sS -o "$BODY_FILE" -w "%{http_code}" \
              --fail \
              --max-time 120 \
              -X POST "${{ secrets.CRON_TICK_URL }}" \
              -H "Content-Type: application/json" \
              -H "x-cron-secret: ${{ secrets.CRON_SECRET }}" \
              -d '{"timestamp":"'"$TS"'"}')
            CURL_EXIT=$?
            set -e

            if [ "$CURL_EXIT" -eq 28 ]; then
              echo "::warning::curl timeout (28) on attempt $ATTEMPT/$TICK_MAX_CALLS, continuing to next attempt"
              TIMEOUT_COUNT=$((TIMEOUT_COUNT + 1))
              rm -f "$BODY_FILE"
              if [ "$ATTEMPT" -lt "$TICK_MAX_CALLS" ]; then
                echo "Sleeping ${TICK_SLEEP_SEC}s before next attempt..."
                sleep "$TICK_SLEEP_SEC"
              fi
              continue
            fi

            if [ "$CURL_EXIT" -ne 0 ]; then
              echo "::error::cron-tick curl failed (attempt $ATTEMPT/$TICK_MAX_CALLS, exit code $CURL_EXIT, HTTP $HTTP_STATUS)"
              cat "$BODY_FILE" | head -c 1000
              rm -f "$BODY_FILE"
              exit 1
            fi

            BODY=$(cat "$BODY_FILE")
            rm -f "$BODY_FILE"

            BODY_TRUNCATED=$(printf '%s' "$BODY" | head -c 1000)
            echo "attempt=$ATTEMPT http_status=$HTTP_STATUS body=$BODY_TRUNCATED"

            # Parse status from JSON response for logging only (no flow control)
            RESP_STATUS=$(python3 -c "
          import json, sys
          try:
              data = json.loads(sys.argv[1])
              print(data.get('status', 'unknown'))
          except Exception:
              print('unknown')
          " "$BODY" 2>/dev/null || echo "unknown")

            echo "parsed_status=$RESP_STATUS"

            if [ "$ATTEMPT" -lt "$TICK_MAX_CALLS" ]; then
              echo "Sleeping ${TICK_SLEEP_SEC}s before next attempt..."
              sleep "$TICK_SLEEP_SEC"
            fi
          done

          if [ "$TIMEOUT_COUNT" -eq "$TICK_MAX_CALLS" ]; then
            echo "::error::all $TICK_MAX_CALLS attempts timed out (curl 28)"
            exit 1
          fi

          echo "cron-tick loop completed (timeouts: $TIMEOUT_COUNT/$TICK_MAX_CALLS)"
