name: Cron Tick (every 1 minute)

on:
  schedule:
    - cron: "* * * * *"
  workflow_dispatch: {}

concurrency:
  group: cron-tick
  cancel-in-progress: false

jobs:
  cron-tick:
    runs-on: ubuntu-latest
    env:
      TICK_MAX_CALLS: "4"
      TICK_SLEEP_ACTIVE_SEC: "75"
      TICK_SLEEP_STALL_SEC: "210"
      STALL_THRESHOLD_SEC: "180"
      STALL_BUFFER_SEC: "15"
    steps:
      - name: Validate secrets
        run: |
          if [ -z "${{ secrets.CRON_TICK_URL }}" ]; then
            echo "::error::Secret CRON_TICK_URL is not configured. Go to Settings > Secrets and variables > Actions and add CRON_TICK_URL (the full URL of your cron-tick Edge Function, e.g. https://<project-id>.supabase.co/functions/v1/cron-tick)."
            exit 1
          fi
          if [ -z "${{ secrets.CRON_SECRET }}" ]; then
            echo "::error::Secret CRON_SECRET is not configured. Go to Settings > Secrets and variables > Actions and add CRON_SECRET (must match the CRON_SECRET Supabase secret)."
            exit 1
          fi

      - name: Validate tick loop configuration
        run: |
          for VAR_NAME in TICK_MAX_CALLS TICK_SLEEP_ACTIVE_SEC TICK_SLEEP_STALL_SEC STALL_THRESHOLD_SEC STALL_BUFFER_SEC; do
            VAL=$(eval echo "\$$VAR_NAME")
            if ! [[ "$VAL" =~ ^[0-9]+$ ]]; then
              echo "::error::$VAR_NAME must be an integer (got: $VAL)"
              exit 1
            fi
          done
          if [ "$TICK_MAX_CALLS" -lt 1 ] || [ "$TICK_MAX_CALLS" -gt 12 ]; then
            echo "::error::TICK_MAX_CALLS out of range: $TICK_MAX_CALLS (expected 1..12)"
            exit 1
          fi
          if [ "$TICK_SLEEP_ACTIVE_SEC" -lt 61 ] || [ "$TICK_SLEEP_ACTIVE_SEC" -gt 300 ]; then
            echo "::error::TICK_SLEEP_ACTIVE_SEC out of range: $TICK_SLEEP_ACTIVE_SEC (expected 61..300)"
            exit 1
          fi
          if [ "$TICK_SLEEP_STALL_SEC" -lt 61 ] || [ "$TICK_SLEEP_STALL_SEC" -gt 300 ]; then
            echo "::error::TICK_SLEEP_STALL_SEC out of range: $TICK_SLEEP_STALL_SEC (expected 61..300)"
            exit 1
          fi
          if [ "$STALL_THRESHOLD_SEC" -lt 60 ] || [ "$STALL_THRESHOLD_SEC" -gt 600 ]; then
            echo "::error::STALL_THRESHOLD_SEC out of range: $STALL_THRESHOLD_SEC (expected 60..600)"
            exit 1
          fi
          if [ "$STALL_BUFFER_SEC" -lt 0 ] || [ "$STALL_BUFFER_SEC" -gt 60 ]; then
            echo "::error::STALL_BUFFER_SEC out of range: $STALL_BUFFER_SEC (expected 0..60)"
            exit 1
          fi

      - name: Diagnostic fingerprint (workflow_dispatch only)
        if: github.event_name == 'workflow_dispatch'
        run: |
          SECRET="${{ secrets.CRON_SECRET }}"
          SECRET_LEN=${#SECRET}
          echo "secret_len=$SECRET_LEN"
          if [ "$SECRET_LEN" -lt 16 ]; then
            echo "::error::CRON_SECRET is too short ($SECRET_LEN chars, minimum 16)"
            exit 1
          fi
          FP12=$(printf "%s" "${SECRET}cron-fp-v1" | sha256sum | awk '{print $1}' | cut -c1-12)
          echo "secret_fp12=$FP12"

      - name: Call cron-tick (conditional multi-tick)
        run: |
          for ATTEMPT in $(seq 1 "$TICK_MAX_CALLS"); do
            TS=$(date -u +%Y-%m-%dT%H:%M:%SZ)
            BODY_FILE=$(mktemp)
            STATUS=$(curl -sS -o "$BODY_FILE" -w "%{http_code}" -X POST "${{ secrets.CRON_TICK_URL }}" \
              -H "Content-Type: application/json" \
              -H "x-cron-secret: ${{ secrets.CRON_SECRET }}" \
              -d '{"timestamp":"'"$TS"'"}')
            BODY=$(cat "$BODY_FILE")
            BODY_TRUNCATED=$(printf '%s' "$BODY" | head -c 1000)

            if [ "$STATUS" -ge 400 ]; then
              echo "attempt=$ATTEMPT timestamp=$TS http_status=$STATUS"
              echo "body=$BODY_TRUNCATED"
              rm -f "$BODY_FILE"
              echo "::error::cron-tick returned HTTP $STATUS on attempt $ATTEMPT"
              exit 1
            fi

            PY_SCRIPT=$(mktemp)
            cat > "$PY_SCRIPT" << 'PYEOF'
import json, sys, os

path = sys.argv[1]
active_sleep = int(os.environ.get("TICK_SLEEP_ACTIVE_SEC", "75"))
stall_threshold = int(os.environ.get("STALL_THRESHOLD_SEC", "180"))
stall_buffer = int(os.environ.get("STALL_BUFFER_SEC", "15"))

try:
    with open(path, "r", encoding="utf-8") as f:
        data = json.load(f)
except Exception as e:
    print("PARSE_OK=false")
    print("SHOULD_CONTINUE=false")
    print(f"PARSE_ERROR={e}")
    print(f"STATUS=parse_error")
    print("LAST_EVENT_AGE_S=")
    print(f"SLEEP_SEC={active_sleep}")
    sys.exit(0)

status = str(data.get("status", ""))
last_event_age_s = data.get("last_event_age_s")

# Determine SHOULD_CONTINUE
noop_statuses = {"noop", "no_work", "done", "completed"}
continue_statuses = {
    "yielded", "retry_started",
    "resume_skipped_active_window", "resume_skipped_within_stall_window",
    "resumed", "resume_triggered",
}

if status in noop_statuses:
    should_continue = False
elif (
    data.get("is_yielded") is True
    or data.get("is_stalled") is True
    or status in continue_statuses
):
    should_continue = True
else:
    should_continue = False

# Determine SLEEP_SEC
sleep_sec = active_sleep

if status == "resume_skipped_within_stall_window" and isinstance(last_event_age_s, (int, float)):
    raw = stall_threshold - int(last_event_age_s) + stall_buffer
    sleep_sec = max(61, min(300, raw))

age_str = str(int(last_event_age_s)) if isinstance(last_event_age_s, (int, float)) else ""

print("PARSE_OK=true")
print(f"STATUS={status}")
print(f"LAST_EVENT_AGE_S={age_str}")
print(f"SHOULD_CONTINUE={'true' if should_continue else 'false'}")
print(f"SLEEP_SEC={sleep_sec}")
PYEOF

            PARSE_RESULT=$(python3 "$PY_SCRIPT" "$BODY_FILE")
            rm -f "$PY_SCRIPT" "$BODY_FILE"

            RESP_STATUS=$(echo "$PARSE_RESULT" | awk -F= '/^STATUS=/{print $2}')
            LAST_AGE=$(echo "$PARSE_RESULT" | awk -F= '/^LAST_EVENT_AGE_S=/{print $2}')
            SHOULD_CONTINUE=$(echo "$PARSE_RESULT" | awk -F= '/^SHOULD_CONTINUE=/{print $2}')
            SLEEP_SEC=$(echo "$PARSE_RESULT" | awk -F= '/^SLEEP_SEC=/{print $2}')

            echo "attempt=$ATTEMPT timestamp=$TS http_status=$STATUS status=$RESP_STATUS last_event_age_s=$LAST_AGE sleep_sec=$SLEEP_SEC should_continue=$SHOULD_CONTINUE"
            echo "body=$BODY_TRUNCATED"

            if [ "$SHOULD_CONTINUE" != "true" ]; then
              echo "No further work detected; stopping after attempt $ATTEMPT"
              break
            fi

            if [ "$ATTEMPT" -lt "$TICK_MAX_CALLS" ]; then
              echo "Work still pending; sleeping ${SLEEP_SEC}s before next attempt"
              sleep "$SLEEP_SEC"
            else
              echo "Reached max attempts ($TICK_MAX_CALLS) with work still pending"
            fi
          done
